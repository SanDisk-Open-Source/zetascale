/*
 * Copyright (c) 2009-2016, SanDisk Corporation. All rights reserved.
 * No use, or distribution, of this source code is permitted in any form or
 * means without a valid, written license agreement with SanDisk Corp.  Please
 * refer to the included End User License Agreement (EULA), "License" or "License.txt" file
 * for terms and conditions regarding the use and redistribution of this software.
 */

/*
 * File:  fcnl_framework_cursor_test.c
 * Author: Zhenwei Lu
 *
 * For cover rpm/curor APIs
 * Scenario:
 * - 5 node cluster, 3 num_replicas, super node on node 0
 * - create shard on node 1 (home node)
 * - write on node 1, key1
 * - read on node 2
 * - crash node 2
 * - write on node 1, key2, key3
 * - read on node 1, key2
 * - delete on node 1 key3
 * - restart node 2
 * - get last seqno on node 2 (GLS)
 * - GIC and GBC
 *
 * Created on Nov 19, 2008, 12:04 AM
 *
 * Copyright Schooner Information Technology, Inc.
 * http://www.schoonerinfotech.com/
 *
 * $Id$
 */


#include "fth/fthOpt.h"
#include "platform/stdio.h"
#include "test_framework.h"

#define RT_USE_COMMON 1
#include "test_common.h"

/*
 * We use a sub-category under test because test implies a huge number
 * of log messages out of simulated networking, flash, etc.
 */
PLAT_LOG_SUBCAT_LOCAL(LOG_CAT, PLAT_LOG_CAT_SDF_PROT_REPLICATION,
                      "test/case");


#define PLAT_OPTS_NAME(name) name ## _sync_test
#include "platform/opts.h"
#include "misc/misc.h"

#define PLAT_OPTS_ITEMS_sync_test() \
    PLAT_OPTS_COMMON_TEST(common_config)

#define SLEEP_US 1000000

struct plat_opts_config_sync_test {
    struct rt_common_test_config common_config;
};

/**
 * @brief synchronized create_shard/write/read/delete/delete_shard operations
 */
void
user_operations_cursor_test(uint64_t args) {
    struct replication_test_framework *test_framework =
            (struct replication_test_framework *)args;
    SDF_boolean_t op_ret = SDF_FALSE;
    struct SDF_shard_meta *shard_meta = NULL;
    SDF_replication_props_t *replication_props = NULL;
    int failed = 0;
    uint64_t seqno = 0;
    SDF_shardid_t shard_id = 2;
    vnode_t node_id = 1;
    struct timeval now;
    struct timeval when;
    /* timeval incre */
    struct timeval incre;

    void *data_read;
    size_t data_read_len;

    uint64_t          seqno_start, seqno_len, seqno_max;
    int               i;
    int               ncursors;
    it_cursor_t      *pit;
    resume_cursor_t  *prc = NULL;
    char              skey[1024];
    SDF_time_t        exptime;
    SDF_time_t        createtime;
    int               key_len;
    size_t            data_len;
    void             *pdata;
    int               resume_cursor_size = 0;
    char             *pcur;

    shard_id = __sync_add_and_fetch(&test_framework->max_shard_id, 1);
    char *key;
    char *data;

    failed = !plat_calloc_struct(&meta);
    replication_test_meta_init(meta);

    /* Assure test_framework is started?! */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "start test_framework");
    rtfw_start(test_framework);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "test_framework started\n");

    /* Start all nodes */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "start nodes");
    rtfw_start_all_nodes(test_framework);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "nodes started");

    plat_assert(!failed);
    failed = !plat_calloc_struct(&replication_props);
    plat_assert(!failed);
    rtfw_set_default_replication_props(&test_framework->config, replication_props);
    shard_meta = rtfw_init_shard_meta(&test_framework->config,
                                      1 /* first_node */,
                                      shard_id
                                      /* shard_id, in real system generated by generate_shard_ids() */,
                                      replication_props);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                  create shard sync                 "
                 "\n**************************************************");
    op_ret = rtfw_create_shard_sync(test_framework, 1, shard_meta);
    plat_assert(op_ret == SDF_SUCCESS);

    /* - write on node 1, key:google:1, data:Sebstian:1 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                 write object sync                  "
                 "\n**************************************************");
    plat_asprintf(&key, "google:%d", 1);
    plat_asprintf(&data, "Sebstian:%d", 1);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "write key:%s, key_len:%u, data:%s, data_len:%u",
                 key, (int)(strlen(key)), data, (int)(strlen(data)));
    op_ret = rtfw_write_sync(test_framework,
                             shard_id /* shard */, 1 /* node */,
                             meta /* test_meta */,
                             key, strlen(key)+1, data, strlen(data)+1);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_free(key);
    plat_free(data);

    /* - read on node 1, key:google:1 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                  read object sync                  "
                 "\n**************************************************");
    replication_test_framework_read_data_free_cb_t free_cb =
        replication_test_framework_read_data_free_cb_create(PLAT_CLOSURE_SCHEDULER_ANY_OR_SYNCHRONOUS,
                                                            &rtfw_read_free,
                                                            test_framework);
    plat_asprintf(&key, "google:%d", 1);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "KEY:%s, key_len:%d", key, (int)strlen(key));

    op_ret = rtfw_read_sync(test_framework, shard_id /* shard */, node_id /* node */, key, strlen(key) + 1,
                            &data_read, &data_read_len, &free_cb);
    plat_free(key);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "read data:%s, data_len:%d", (char *)data_read, (int)data_read_len);
    plat_free(data_read);

    /* crash node 2 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                  crash node 2 sync                  "
                 "\n**************************************************");
    rtfw_crash_node_sync(test_framework, 2);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "crash node:%"PRIu32" complete", 2);

    /**
     * write on node 1, key2: google:2, data2: Sebstian:2,
     * key3: google:3, data3: Sebstian:3
     */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                 write object sync                  "
                 "\n**************************************************");
    plat_asprintf(&key, "google:%d", 2);
    plat_asprintf(&data, "Sebstian:%d", 2);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "write key:%s, key_len:%u, data:%s, data_len:%u",
                 key, (int)(strlen(key)), data, (int)(strlen(data)));
    op_ret = rtfw_write_sync(test_framework,
                             shard_id /* shard */, 1 /* node */,
                             meta /* test_meta */,
                             key, strlen(key)+1, data, strlen(data)+1);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_free(key);
    plat_free(data);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                 write object sync                  "
                 "\n**************************************************");
    plat_asprintf(&key, "google:%d", 3);
    plat_asprintf(&data, "Sebstian:%d", 3);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "write key:%s, key_len:%u, data:%s, data_len:%u",
                 key, (int)(strlen(key)), data, (int)(strlen(data)));
    op_ret = rtfw_write_sync(test_framework,
                             shard_id /* shard */, 1 /* node */,
                             meta /* test_meta */,
                             key, strlen(key)+1, data, strlen(data)+1);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_free(key);
    plat_free(data);


    /* read on node 1, key2: google:2 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n**************************************************\n"
                 "                  read object sync                  "
                 "\n**************************************************");
    plat_asprintf(&key, "google:%d", 2);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "KEY:%s, key_len:%d", key, (int)strlen(key));

    op_ret = rtfw_read_sync(test_framework, shard_id /* shard */, 1 /* node */, key, strlen(key) + 1,
                            &data_read, &data_read_len, &free_cb);
    plat_free(key);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "read data:%s, data_len:%d", (char *)data_read, (int)data_read_len);
    plat_free(data_read);


    /* delete from node 1, key3: google3 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n***************************************************\n"
                 "                  delete object sync                 "
                 "\n***************************************************");
    plat_asprintf(&key, "google:%d", 3);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                 "KEY:%s, key_len:%d", key, (int)(strlen(key)));

    op_ret = rtfw_delete_sync(test_framework, shard_id /* shard */, 1 /* node */, key, strlen(key)+1);
    plat_assert(op_ret == SDF_SUCCESS);
    plat_free(key);

    /* restart node 2 */
    op_ret = rtfw_start_node(test_framework, 2);
    plat_assert(op_ret == SDF_SUCCESS);

    /* block a while */
    now = test_framework->now;
    incre.tv_sec = 10;
    incre.tv_usec = 0;
    timeradd(&now, &incre, &when);
    rtfw_block_until(test_framework, (const struct timeval)when);
    rtfw_sleep_usec(test_framework, SLEEP_US);

    /* get last seqno from node 2 */
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n************************************************************\n"
                 "                 get latest seqno from node 2                "
                 "\n************************************************************");

    op_ret = rtfw_get_last_seqno_sync(test_framework, 2, shard_id, &seqno);

    if (op_ret == SDF_SUCCESS) {
        plat_log_msg(LOG_ID, LOG_CAT, LOG_INFO, "get_last_seqno succeeded! (seqno=%"PRIu64")", seqno);
    } else {
        plat_log_msg(LOG_ID, LOG_CAT, LOG_INFO, "get_last_seqno failed!");
    }

    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n************************************************************\n"
                 "                        get iteration cursors                  "
                 "\n************************************************************");

    prc = NULL;
    resume_cursor_size = 0;
    while (1) {
        replication_test_framework_read_data_free_cb_t free_cb =
            replication_test_framework_read_data_free_cb_create(PLAT_CLOSURE_SCHEDULER_ANY_OR_SYNCHRONOUS,
                                                                &rtfw_read_free,
                                                                test_framework);

        seqno_start        = 0;
        seqno_len          = 10;
        seqno_max          = UINT64_MAX - 1;
        op_ret = rtfw_get_cursors_sync(test_framework, shard_id, node_id,
                                       seqno_start, seqno_len, seqno_max,
                                       (void *) prc, resume_cursor_size,
                                       (void **) &pit, &data_len, &free_cb);

        if (op_ret != SDF_SUCCESS) {
            plat_log_msg(LOG_ID, LOG_CAT, LOG_INFO, "get_iteration_cursors failed!");
            break;
        } else {
            ncursors = pit->cursor_count;
            if (ncursors == 0) {
                break;
            }
            prc = &(pit->resume_cursor);
            resume_cursor_size = sizeof(resume_cursor_t);
            plat_assert(data_len == (sizeof(it_cursor_t) + seqno_len*pit->cursor_len));
            plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "get_iteration_cursors succeeded (%d cursors returned)!", ncursors);

            pcur = pit->cursors;
            for (i = 0; i < ncursors; i++) {
                replication_test_framework_read_data_free_cb_t free_cb =
                replication_test_framework_read_data_free_cb_create(PLAT_CLOSURE_SCHEDULER_ANY_OR_SYNCHRONOUS,
                                                                    &rtfw_read_free,
                                                                    test_framework);
                op_ret = rtfw_get_by_cursor_sync(test_framework, shard_id, node_id,
                                                 (void *) pcur, pit->cursor_len,
                                                 skey, 1024, &key_len,
                                                 &exptime, &createtime, &seqno,
                                                 &pdata, &data_len, &free_cb);
                pcur += pit->cursor_len;

                if (op_ret == SDF_SUCCESS) {
                    plat_log_msg(LOG_ID, LOG_CAT, LOG_TRACE,
                                 "get_by_cursor: %s, key_len:%u, data:%s, data_len:%u,"
                                 "seqno: %"PRIu64", exptime:%"PRIu32", createtime:%"PRIu32"",
                                 skey, key_len, (char *)pdata, (unsigned)data_len,
                                 seqno, exptime, createtime);
                    plat_free(pdata);
                } else {
                    plat_log_msg(LOG_ID, LOG_CAT, LOG_INFO, "get_by_cursor failed!");
                }
            }
        }
    }
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n************************************************************\n"
                 "                  Test framework shutdown                       "
                 "\n************************************************************");
    rtfw_shutdown_sync(test_framework);

    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG,
                 "\n************************************************************\n"
                 "                  Test framework sync summary                 "
                 "\n************************************************************");
    plat_free(meta);
    plat_free(replication_props);
    plat_free(shard_meta);

    /* Terminate scheduler if idle_thread exit */
    while (test_framework->timer_dispatcher) {
        fthYield(-1);
    }
    plat_free(test_framework);

    fthKill(1);
}

int main(int argc, char **argv) {
    SDF_status_t status;
    struct replication_test_framework *test_framework = NULL;

    struct plat_opts_config_sync_test opts_config;
    memset(&opts_config, 0, sizeof (opts_config));

    rt_common_test_config_init(&opts_config.common_config);
    /* Three plus the super node */
    opts_config.common_config.test_config.nnode = 4;
    opts_config.common_config.test_config.replication_type =
        SDF_REPLICATION_META_SUPER_NODE;
    opts_config.common_config.test_config.replicator_config.lease_usecs =
        100 * MILLION;


    int opts_status = plat_opts_parse_sync_test(&opts_config, argc, argv);
    if (opts_status) {
        return (1);
    }

    status = rt_sm_init(&opts_config.common_config.shmem_config);
    if (status) {
        return (1);
    }

    /* start fthread library */
    fthInit();

    test_framework =
        replication_test_framework_alloc(&opts_config.common_config.test_config);
    if (test_framework) {
        plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "test_framework %p allocated\n",
                     test_framework);
    }
    XResume(fthSpawn(&user_operations_cursor_test, 40960), (uint64_t)test_framework);
    fthSchedulerPthread(0);
    plat_log_msg(LOG_ID, LOG_CAT, LOG_DBG, "JOIN");

    rt_sm_detach();

    rt_common_test_config_destroy(&opts_config.common_config);

    return (0);
}
#include "platform/opts_c.h"
