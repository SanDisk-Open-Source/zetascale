/*
 * ZS linkage; generated by mkzsdll.
 * Copyright (c) 2012-2013, SanDisk Corporation.  All rights reserved.
 */
#include <dlfcn.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "zs.h"


/*
 * Macros.
 */
#define nel(a)      (sizeof(a)/sizeof(*(a)))
#define unlikely(x) __builtin_expect((x), 0)


/*
 * Set once ZS has been loaded.
 */
static int loaded;


/*
 * ZS Library locations.
 */
static char *zslibs[] ={
    "/usr/lib64/zs/libzs.so",
    "/usr/lib/zs/libzs.so",
    "/lib64/libzs.so",
    "/lib/libzs.so",
    "/usr/local/lib64/libzs.so",
    "/usr/local/lib/libzs.so",
    "libzs.so",
};


/*
 * Function pointers.
 */
static const char *
(*ptr_ZSGetProperty)(const char *key, const char *def);

static ZS_status_t
(*ptr_ZSSetProperty)(const char *property, const char *value);

static ZS_status_t 
(*ptr_ZSLoadProperties)(const char *prop_file);

static ZS_status_t 
(*ptr_ZSInitVersioned)(struct ZS_state **zs_state, uint32_t api_version);

static ZS_status_t 
(*ptr_ZSInitPerThreadState)(struct ZS_state *zs_state,
                             struct ZS_thread_state **thd_state);

static ZS_status_t 
(*ptr_ZSReleasePerThreadState)(struct ZS_thread_state **thd_state);

static ZS_status_t 
(*ptr_ZSShutdown)(struct ZS_state *zs_state);

static ZS_status_t 
(*ptr_ZSLoadCntrPropDefaults)(ZS_container_props_t *props);

static ZS_status_t 
(*ptr_ZSOpenContainer)(struct ZS_thread_state *zs_thread_state,
                        char *cname,
                        ZS_container_props_t *properties,
                        uint32_t flags,
                        ZS_cguid_t *cguid);

static ZS_status_t 
(*ptr_ZSOpenContainerSpecial)(struct ZS_thread_state *zs_thread_state,
                               char *cname,
                               ZS_container_props_t *properties,
                               uint32_t flags,
                               ZS_container_meta_t *cmeta,
                               ZS_cguid_t *cguid);

static ZS_status_t 
(*ptr_ZSCloseContainer)(struct ZS_thread_state *zs_thread_state,
                         ZS_cguid_t cguid);

static ZS_status_t 
(*ptr_ZSDeleteContainer)(struct ZS_thread_state *zs_thread_state,
                          ZS_cguid_t cguid);

static ZS_status_t 
(*ptr_ZSGetContainers)(struct ZS_thread_state *zs_thread_state,
                        ZS_cguid_t *cguids,
                        uint32_t *n_cguids);

static ZS_status_t 
(*ptr_ZSGetContainerProps)(struct ZS_thread_state *zs_thread_state,
                            ZS_cguid_t cguid,
                            ZS_container_props_t *pprops);

static ZS_status_t 
(*ptr_ZSSetContainerProps)(struct ZS_thread_state *zs_thread_state,
                            ZS_cguid_t cguid,
                            ZS_container_props_t *pprops);

static ZS_status_t 
(*ptr_ZSReadObject)(struct ZS_thread_state *zs_thread_state,
                     ZS_cguid_t cguid,
                     char *key,
                     uint32_t keylen,
                     char **data,
                     uint64_t *datalen);

static ZS_status_t 
(*ptr_ZSReadObjectExpiry)(struct ZS_thread_state *zs_thread_state,
                           ZS_cguid_t cguid,
                           ZS_readobject_t *robj);

static ZS_status_t 
(*ptr_ZSFreeBuffer)(char *buf);

static ZS_status_t 
(*ptr_ZSWriteObject)(struct ZS_thread_state *sdf_thread_state,
                      ZS_cguid_t cguid,
                      char *key,
                      uint32_t keylen,
                      char *data,
                      uint64_t datalen,
                      uint32_t flags);

static ZS_status_t 
(*ptr_ZSWriteObjectExpiry)(struct ZS_thread_state *zs_thread_state,
                            ZS_cguid_t cguid,
                            ZS_writeobject_t *wobj,
                            uint32_t flags);

static ZS_status_t 
(*ptr_ZSDeleteObject)(struct ZS_thread_state *zs_thread_state,
                       ZS_cguid_t cguid,
                       char *key,
                       uint32_t keylen);

static ZS_status_t 
(*ptr_ZSEnumerateContainerObjects)(struct ZS_thread_state *zs_thread_state,
                                    ZS_cguid_t cguid,
                                    struct ZS_iterator **iterator);

static ZS_status_t 
(*ptr_ZSNextEnumeratedObject)(struct ZS_thread_state *zs_thread_state,
                               struct ZS_iterator *iterator,
                               char **key,
                               uint32_t *keylen,
                               char **data,
                               uint64_t *datalen);

static ZS_status_t 
(*ptr_ZSFinishEnumeration)(struct ZS_thread_state *zs_thread_state,
                            struct ZS_iterator *iterator);

static ZS_status_t 
(*ptr_ZSFlushObject)(struct ZS_thread_state *zs_thread_state,
                      ZS_cguid_t cguid,
                      char *key,
                      uint32_t keylen);

static ZS_status_t 
(*ptr_ZSFlushContainer)(struct ZS_thread_state *zs_thread_state,
                         ZS_cguid_t cguid);

static ZS_status_t 
(*ptr_ZSFlushCache)(struct ZS_thread_state *zs_thread_state);

static ZS_status_t 
(*ptr_ZSGetStats)(struct ZS_thread_state *zs_thread_state,
                   ZS_stats_t *stats);

static ZS_status_t 
(*ptr_ZSGetContainerStats)(struct ZS_thread_state *zs_thread_state,
                            ZS_cguid_t cguid,
                            ZS_stats_t *stats);

static char *
(*ptr_ZSStrError)(ZS_status_t zs_errno);

static ZS_status_t 
(*ptr_ZSTransactionStart)(struct ZS_thread_state *zs_thread_state);

static ZS_status_t 
(*ptr_ZSTransactionCommit)(struct ZS_thread_state *zs_thread_state);

static ZS_status_t 
(*ptr_ZSTransactionRollback)(struct ZS_thread_state *zs_thread_state);

static ZS_status_t 
(*ptr_ZSTransactionQuit)(struct ZS_thread_state *zs_thread_state);

static uint64_t
(*ptr_ZSTransactionID)(struct ZS_thread_state *zs_thread_state);

static ZS_status_t
(*ptr_ZSTransactionService)(struct ZS_thread_state *zs_thread_state, int, void *);

static ZS_status_t
(*ptr_ZSTransactionGetMode)(struct ZS_thread_state *zs_thread_state, int *mode);

static ZS_status_t
(*ptr_ZSTransactionSetMode)(struct ZS_thread_state *zs_thread_state, int mode);

static ZS_status_t 
(*ptr_ZSGetVersion)(char **str);

static ZS_status_t 
(*ptr_ZSGetRange)(struct ZS_thread_state *zs_thread_state,
                  ZS_cguid_t              cguid, 
                  ZS_indexid_t            indexid,
                  struct ZS_cursor      **cursor,
                  ZS_range_meta_t        *rmeta);

static ZS_status_t
(*ptr_ZSGetNextRange)(struct ZS_thread_state *thrd_state,  
                       struct ZS_cursor       *cursor,
                       int                      n_in, 
                       int                     *n_out,
                       ZS_range_data_t        *values);

static ZS_status_t 
(*ptr_ZSGetRangeFinish)(struct ZS_thread_state *thrd_state, 
                         struct ZS_cursor *cursor);
static ZS_status_t
(*ptr_ZSMPut) (struct ZS_thread_state *zs_ts,
        ZS_cguid_t cguid,
        uint32_t num_objs,
        ZS_obj_t *objs,
	uint32_t flags,
	uint32_t *objs_written);

ZS_status_t
(*ptr_ZSRangeUpdate) (struct ZS_thread_state *zs_thread_state, 
	       ZS_cguid_t cguid,
	       char *range_key,
	       uint32_t range_key_len,
	       ZS_range_update_cb_t callback_func,
	       void * callback_args,	
	       ZS_range_cmp_cb_t range_cmp_callback,
	       void *range_cmp_callback_args,
	       uint32_t *objs_updated);

/*
 * ZSCheckBtree: internal api for testing purpose.
 */
ZS_status_t
(*ptr_ZSCheckBtree) (struct ZS_thread_state *zs_thread_state, 
	       ZS_cguid_t cguid);

ZS_status_t
(*ptr_ZSCheck) (struct ZS_thread_state *zs_thread_state);

ZS_status_t
(*ptr_ZSIoctl)(struct ZS_thread_state *zs_thread_state, 
         ZS_cguid_t cguid,
         uint32_t ioctl_type,
         void *data);


ZS_status_t
(*ptr_ZSCreateContainerSnapshot)(struct ZS_thread_state *ts,
							ZS_cguid_t cguid,
							uint64_t *snap_seq);

ZS_status_t
(*ptr_ZSDeleteContainerSnapshot)(struct ZS_thread_state *ts,
									ZS_cguid_t cguid,
									uint64_t snap_seq);

ZS_status_t
(*ptr_ZSGetContainerSnapshots)(struct ZS_thread_state *ts,
									ZS_cguid_t cguid,
									uint32_t *n_snapshots,
									ZS_container_snapshots_t **snap_seqs);
ZS_status_t (*ptr_ZSScavenger) (struct ZS_state *zs_state);
ZS_status_t (*ptr_ZSScavengeContainer) (struct ZS_state *zs_state, ZS_cguid_t cguid);
ZS_status_t (*ptr_ZSScavengeSnapshot) (struct ZS_state *zs_state, ZS_cguid_t cguid, uint64_t snap_seq);

static void 
(*ptr_ZSTLMapDestroy)(struct ZSTLMap *pm);

static void 
(*ptr_ZSTLMapClear)(struct ZSTLMap *pm);

static struct ZSTLMapEntry *
(*ptr_ZSTLMapCreate)(struct ZSTLMap *pm,
                      char *pkey,
                      uint32_t keylen,
                      char *pdata,
                      uint64_t datalen);

static struct ZSTLMapEntry *
(*ptr_ZSTLMapUpdate)(struct ZSTLMap *pm,
                      char *pkey,
                      uint32_t keylen,
                      char *pdata,
                      uint64_t datalen);

static struct ZSTLMapEntry *
(*ptr_ZSTLMapSet)(struct ZSTLMap *pm,
                   char *pkey,
                   uint32_t keylen,
                   char *pdata,
                   uint64_t datalen,
                   char **old_pdata,
                   uint64_t *old_datalen);

static struct ZSTLMapEntry *
(*ptr_ZSTLMapGet)(struct ZSTLMap *pc,
                   char *key,
                   uint32_t keylen,
                   char **data,
                   uint64_t *pdatalen);

static int 
(*ptr_ZSTLMapIncrRefcnt)(struct ZSTLMap *pm, char *key, uint32_t keylen);

static void 
(*ptr_ZSTLMapCheckRefcnts)(struct ZSTLMap *pm);

static int 
(*ptr_ZSTLMapRelease)(struct ZSTLMap *pm, char *key, uint32_t keylen);

static int 
(*ptr_ZSTLMapReleaseEntry)(struct ZSTLMap *pm, struct ZSTLMapEntry *pme);

static struct ZSTLIterator *
(*ptr_ZSTLMapEnum)(struct ZSTLMap *pm);

static void 
(*ptr_ZSTLFinishEnum)(struct ZSTLMap *pm, struct ZSTLIterator *iterator);

static int 
(*ptr_ZSTLMapNextEnum)(struct ZSTLMap *pm,
                        struct ZSTLIterator *iterator,
                        char **key,
                        uint32_t *keylen,
                        char **data,
                        uint64_t *datalen);

static int 
(*ptr_ZSTLMapDelete)(struct ZSTLMap *pm, char *key, uint32_t keylen);

struct ZSTLMap*
(*ptr_ZSTLMapInit)(uint64_t nbuckets, uint64_t max_entries, char use_locks, void (*replacement_callback)(void *callback_data, char *key, uint32_t keylen, char *pdata, uint64_t datalen), void *replacement_callback_data);

/*
 * Linkage table.
 */
static struct {
    const char *name;
    void       *func;
} table[] ={
    { "_ZSGetProperty",                &ptr_ZSGetProperty               },
    { "_ZSSetProperty",                &ptr_ZSSetProperty               },
    { "_ZSLoadProperties",             &ptr_ZSLoadProperties            },
    { "_ZSInitVersioned",              &ptr_ZSInitVersioned             },
    { "_ZSInitPerThreadState",         &ptr_ZSInitPerThreadState        },
    { "_ZSReleasePerThreadState",      &ptr_ZSReleasePerThreadState     },
    { "_ZSShutdown",                   &ptr_ZSShutdown                  },
    { "_ZSLoadCntrPropDefaults",       &ptr_ZSLoadCntrPropDefaults      },
    { "_ZSOpenContainer",              &ptr_ZSOpenContainer             },
    { "_ZSOpenContainerSpecial",       &ptr_ZSOpenContainerSpecial      },
    { "_ZSCloseContainer",             &ptr_ZSCloseContainer            },
    { "_ZSDeleteContainer",            &ptr_ZSDeleteContainer           },
    { "_ZSGetContainers",              &ptr_ZSGetContainers             },
    { "_ZSGetContainerProps",          &ptr_ZSGetContainerProps         },
    { "_ZSSetContainerProps",          &ptr_ZSSetContainerProps         },
    { "_ZSReadObject",                 &ptr_ZSReadObject                },
    { "_ZSReadObjectExpiry",           &ptr_ZSReadObjectExpiry          },
    { "_ZSFreeBuffer",                 &ptr_ZSFreeBuffer                },
    { "_ZSWriteObject",                &ptr_ZSWriteObject               },
    { "_ZSWriteObjectExpiry",          &ptr_ZSWriteObjectExpiry         },
    { "_ZSDeleteObject",               &ptr_ZSDeleteObject              },
    { "_ZSEnumerateContainerObjects",  &ptr_ZSEnumerateContainerObjects },
    { "_ZSNextEnumeratedObject",       &ptr_ZSNextEnumeratedObject      },
    { "_ZSFinishEnumeration",          &ptr_ZSFinishEnumeration         },
    { "_ZSFlushObject",                &ptr_ZSFlushObject               },
    { "_ZSFlushContainer",             &ptr_ZSFlushContainer            },
    { "_ZSFlushCache",                 &ptr_ZSFlushCache                },
    { "_ZSGetStats",                   &ptr_ZSGetStats                  },
    { "_ZSGetContainerStats",          &ptr_ZSGetContainerStats         },
    { "_ZSStrError",                   &ptr_ZSStrError                  },
    { "_ZSTransactionStart",           &ptr_ZSTransactionStart          },
    { "_ZSTransactionCommit",          &ptr_ZSTransactionCommit         },
    { "_ZSTransactionRollback",        &ptr_ZSTransactionRollback       },
    { "_ZSTransactionQuit",            &ptr_ZSTransactionQuit           },
    { "_ZSTransactionID",              &ptr_ZSTransactionID             },
    { "_ZSTransactionService",         &ptr_ZSTransactionService        },
    { "_ZSTransactionGetMode", 	       &ptr_ZSTransactionGetMode	},
    { "_ZSTransactionSetMode", 	       &ptr_ZSTransactionSetMode	},
    { "_ZSGetVersion",                 &ptr_ZSGetVersion                },
    { "_ZSGetRange",                   &ptr_ZSGetRange                  },
    { "_ZSGetNextRange",               &ptr_ZSGetNextRange              },
    { "_ZSGetRangeFinish",             &ptr_ZSGetRangeFinish            },
    { "_ZSMPut",                       &ptr_ZSMPut                      },
    { "_ZSRangeUpdate",                &ptr_ZSRangeUpdate               },
    { "_ZSCheckBtree",                 &ptr_ZSCheckBtree                },
    { "_ZSCheck",                 &ptr_ZSCheck                },
    { "_ZSIoctl",                      &ptr_ZSIoctl                     },
    { "_ZSCreateContainerSnapshot",    &ptr_ZSCreateContainerSnapshot   },
    { "_ZSDeleteContainerSnapshot",    &ptr_ZSDeleteContainerSnapshot   },
    { "_ZSGetContainerSnapshots",      &ptr_ZSGetContainerSnapshots     },
    { "_ZSScavenger",                  &ptr_ZSScavenger                 },
    { "_ZSScavengeContainer",          &ptr_ZSScavengeContainer         },
    { "_ZSScavengeSnapshot",          &ptr_ZSScavengeSnapshot         },
    { "ZSTLMapDestroy",               &ptr_ZSTLMapDestroy              },
    { "ZSTLMapClear",                 &ptr_ZSTLMapClear                },
    { "ZSTLMapCreate",                &ptr_ZSTLMapCreate               },
    { "ZSTLMapUpdate",                &ptr_ZSTLMapUpdate               },
    { "ZSTLMapSet",                   &ptr_ZSTLMapSet                  },
    { "ZSTLMapGet",                   &ptr_ZSTLMapGet                  },
    { "ZSTLMapIncrRefcnt",            &ptr_ZSTLMapIncrRefcnt           },
    { "ZSTLMapCheckRefcnts",          &ptr_ZSTLMapCheckRefcnts         },
    { "ZSTLMapRelease",               &ptr_ZSTLMapRelease              },
    { "ZSTLMapReleaseEntry",          &ptr_ZSTLMapReleaseEntry         },
    { "ZSTLMapEnum",                  &ptr_ZSTLMapEnum                 },
    { "ZSTLFinishEnum",               &ptr_ZSTLFinishEnum              },
    { "ZSTLMapNextEnum",              &ptr_ZSTLMapNextEnum             },
    { "ZSTLMapDelete",                &ptr_ZSTLMapDelete               },
    { "ZSTLMapInit",                  &ptr_ZSTLMapInit                 },
};


/*
 * Print out an error message and exit.
 */
static void
panic(char *fmt, ...)
{
    va_list alist;

    va_start(alist, fmt);
    vfprintf(stderr, fmt, alist);
    va_end(alist);
    fprintf(stderr, "\n");
    exit(1);
}


/*
 * An undefined symbol was found.
 */
static void
undefined(char *sym)
{
    panic("ZS: undefined symbol: %s", sym);
}


/*
 * Determine if the string ends with "No such file or directory".
 */
static int
nsfod(char *str)
{
    char *err = "No such file or directory";
    int  elen = strlen(err);
    int  slen = strlen(str);

    if (slen < elen)
        return 0;
    return !strcmp(str+slen-elen, err);
}


/*
 * Given a pathname, assume it is a ZS library and load it.
 */
static int
load(char *path)
{
    int i;
    void  *dl = dlopen(path, RTLD_NOW | RTLD_DEEPBIND);
    char *err = dlerror();

    if (!dl) {
        if (nsfod(err))
            return 0;
        panic("%s", err);
    }
    
    int n = nel(table);
    for (i = 0; i < n; i++) {
        const char *name = table[i].name;
        void *func = dlsym(dl, name);
        if (func)
            *(void **)table[i].func = func;
        else
            fprintf(stderr, "warning: ZS: undefined symbol: %s\n", name);
    }
    return 1;
}


/*
 * Cause the given library to be loaded.
 */
static void
dlo(const char *lib)
{
    void *dl = dlopen(lib, RTLD_NOW|RTLD_GLOBAL);
    if (!dl) {
        char *err = dlerror();
        fprintf(stderr, "%s\n", err);
        exit(1);
    }
}


/*
 * If the ZS library is not already loaded, attempt to find it and then
 * load it.
 */
static void
parse(void)
{
    if (loaded)
        return;
    loaded = 1;

    dlo("librt.so");
    dlo("libaio.so");
    dlo("libsnappy.so");

    char *lib = getenv("ZS_LIB");
    if (lib) {
        if (load(lib))
            return;
        panic("cannot find ZS_LIB=%s", lib);
    }

    if (load("/usr/lib64/zs/libzs.so"))
        return;

    int i;
    for (i = 0; i < nel(zslibs); i++)
        if (load(zslibs[i]))
            return;
    panic("cannot find libzs.so");
}


/*
 * ZSGetProperty
 */
const char *
ZSGetProperty(const char *key, const char *def)
{
    parse();
    if (unlikely(!ptr_ZSGetProperty))
        undefined("ZSGetProperty");

    return (*ptr_ZSGetProperty)(key, def);
}


/*
 * ZSSetProperty
 */
ZS_status_t
ZSSetProperty(const char *property, const char *value)
{
    parse();
    if (unlikely(!ptr_ZSSetProperty))
        undefined("ZSSetProperty");

    return (*ptr_ZSSetProperty)(property, value);
}


/*
 * ZSLoadProperties
 */
ZS_status_t 
ZSLoadProperties(const char *prop_file)
{
    parse();
    if (unlikely(!ptr_ZSLoadProperties))
        undefined("ZSLoadProperties");

    return (*ptr_ZSLoadProperties)(prop_file);
}


/*
 * ZSInit
 */
ZS_status_t 
ZSInitVersioned(struct ZS_state **zs_state, uint32_t api_version)
{
    parse();
    if (unlikely(!ptr_ZSInitVersioned))
        undefined("ZSInitVersioned");

    return (*ptr_ZSInitVersioned)(zs_state, api_version);
}


/*
 * ZSInitPerThreadState
 */
ZS_status_t 
ZSInitPerThreadState(struct ZS_state *zs_state,
                      struct ZS_thread_state **thd_state)
{
    if (unlikely(!ptr_ZSInitPerThreadState))
        undefined("ZSInitPerThreadState");

    return (*ptr_ZSInitPerThreadState)(zs_state, thd_state);
}


/*
 * ZSReleasePerThreadState
 */
ZS_status_t 
ZSReleasePerThreadState(struct ZS_thread_state **thd_state)
{
    if (unlikely(!ptr_ZSReleasePerThreadState))
        undefined("ZSReleasePerThreadState");

    return (*ptr_ZSReleasePerThreadState)(thd_state);
}


/*
 * ZSShutdown
 */
ZS_status_t 
ZSShutdown(struct ZS_state *zs_state)
{
    if (unlikely(!ptr_ZSShutdown))
        undefined("ZSShutdown");

    return (*ptr_ZSShutdown)(zs_state);
}


/*
 * ZSLoadCntrPropDefaults
 */
ZS_status_t 
ZSLoadCntrPropDefaults(ZS_container_props_t *props)
{
    if (unlikely(!ptr_ZSLoadCntrPropDefaults))
        undefined("ZSLoadCntrPropDefaults");

    return (*ptr_ZSLoadCntrPropDefaults)(props);
}


/*
 * ZSOpenContainer
 */
ZS_status_t 
ZSOpenContainer(struct ZS_thread_state *zs_thread_state,
                 char *cname,
                 ZS_container_props_t *properties,
                 uint32_t flags,
                 ZS_cguid_t *cguid)
{
    if (unlikely(!ptr_ZSOpenContainer))
        undefined("ZSOpenContainer");

    return (*ptr_ZSOpenContainer)(zs_thread_state,
                                   cname,
                                   properties,
                                   flags,
                                   cguid);
}

/*
 * ZSOpenContainerSpecial
 */
ZS_status_t 
ZSOpenContainerSpecial(struct ZS_thread_state *zs_thread_state,
                        char *cname,
                        ZS_container_props_t *properties,
                        uint32_t flags,
                        ZS_container_meta_t *cmeta,
                        ZS_cguid_t *cguid)
{
    if (unlikely(!ptr_ZSOpenContainerSpecial))
        undefined("ZSOpenContainerSpecial");

    return (*ptr_ZSOpenContainerSpecial)(zs_thread_state,
                                          cname,
                                          properties,
                                          flags,
                                          cmeta,
                                          cguid);
}

/*
 * ZSCloseContainer
 */
ZS_status_t 
ZSCloseContainer(struct ZS_thread_state *zs_thread_state,
                  ZS_cguid_t cguid)
{
    if (unlikely(!ptr_ZSCloseContainer))
        undefined("ZSCloseContainer");

    return (*ptr_ZSCloseContainer)(zs_thread_state, cguid);
}


/*
 * ZSDeleteContainer
 */
ZS_status_t 
ZSDeleteContainer(struct ZS_thread_state *zs_thread_state,
                   ZS_cguid_t cguid)
{
    if (unlikely(!ptr_ZSDeleteContainer))
        undefined("ZSDeleteContainer");

    return (*ptr_ZSDeleteContainer)(zs_thread_state, cguid);
}


/*
 * ZSGetContainers
 */
ZS_status_t 
ZSGetContainers(struct ZS_thread_state *zs_thread_state,
                 ZS_cguid_t *cguids,
                 uint32_t *n_cguids)
{
    if (unlikely(!ptr_ZSGetContainers))
        undefined("ZSGetContainers");

    return (*ptr_ZSGetContainers)(zs_thread_state, cguids, n_cguids);
}


/*
 * ZSGetContainerProps
 */
ZS_status_t 
ZSGetContainerProps(struct ZS_thread_state *zs_thread_state,
                     ZS_cguid_t cguid,
                     ZS_container_props_t *pprops)
{
    if (unlikely(!ptr_ZSGetContainerProps))
        undefined("ZSGetContainerProps");

    return (*ptr_ZSGetContainerProps)(zs_thread_state, cguid, pprops);
}


/*
 * ZSSetContainerProps
 */
ZS_status_t 
ZSSetContainerProps(struct ZS_thread_state *zs_thread_state,
                     ZS_cguid_t cguid,
                     ZS_container_props_t *pprops)
{
    if (unlikely(!ptr_ZSSetContainerProps))
        undefined("ZSSetContainerProps");

    return (*ptr_ZSSetContainerProps)(zs_thread_state, cguid, pprops);
}


/*
 * ZSReadObject
 */
ZS_status_t 
ZSReadObject(struct ZS_thread_state *zs_thread_state,
              ZS_cguid_t cguid,
              char *key,
              uint32_t keylen,
              char **data,
              uint64_t *datalen)
{
    if (unlikely(!ptr_ZSReadObject))
        undefined("ZSReadObject");

    return (*ptr_ZSReadObject)(zs_thread_state,
                                cguid,
                                key,
                                keylen,
                                data,
                                datalen);
}


/*
 * ZSReadObjectExpiry
 */
ZS_status_t 
ZSReadObjectExpiry(struct ZS_thread_state *zs_thread_state,
                    ZS_cguid_t cguid,
                    ZS_readobject_t *robj)
{
    if (unlikely(!ptr_ZSReadObjectExpiry))
        undefined("ZSReadObjectExpiry");

    return (*ptr_ZSReadObjectExpiry)(zs_thread_state, cguid, robj);
}


/*
 * ZSFreeBuffer
 */
ZS_status_t 
ZSFreeBuffer(char *buf)
{
    if (unlikely(!ptr_ZSFreeBuffer))
        undefined("ZSFreeBuffer");

    return (*ptr_ZSFreeBuffer)(buf);
}


/*
 * ZSWriteObject
 */
ZS_status_t 
ZSWriteObject(struct ZS_thread_state *sdf_thread_state,
               ZS_cguid_t cguid,
               char *key,
               uint32_t keylen,
               char *data,
               uint64_t datalen,
               uint32_t flags)
{
    if (unlikely(!ptr_ZSWriteObject))
        undefined("ZSWriteObject");

    return (*ptr_ZSWriteObject)(sdf_thread_state,
                                 cguid,
                                 key,
                                 keylen,
                                 data,
                                 datalen,
                                 flags);
}


/*
 * ZSWriteObjectExpiry
 */
ZS_status_t 
ZSWriteObjectExpiry(struct ZS_thread_state *zs_thread_state,
                     ZS_cguid_t cguid,
                     ZS_writeobject_t *wobj,
                     uint32_t flags)
{
    if (unlikely(!ptr_ZSWriteObjectExpiry))
        undefined("ZSWriteObjectExpiry");

    return (*ptr_ZSWriteObjectExpiry)(zs_thread_state, cguid, wobj, flags);
}


/*
 * ZSDeleteObject
 */
ZS_status_t 
ZSDeleteObject(struct ZS_thread_state *zs_thread_state,
                ZS_cguid_t cguid,
                char *key,
                uint32_t keylen)
{
    if (unlikely(!ptr_ZSDeleteObject))
        undefined("ZSDeleteObject");

    return (*ptr_ZSDeleteObject)(zs_thread_state, cguid, key, keylen);
}


/*
 * ZSEnumerateContainerObjects
 */
ZS_status_t 
ZSEnumerateContainerObjects(struct ZS_thread_state *zs_thread_state,
                             ZS_cguid_t cguid,
                             struct ZS_iterator **iterator)
{
    if (unlikely(!ptr_ZSEnumerateContainerObjects))
        undefined("ZSEnumerateContainerObjects");

    return (*ptr_ZSEnumerateContainerObjects)(zs_thread_state,
                                               cguid,
                                               iterator);
}


/*
 * ZSNextEnumeratedObject
 */
ZS_status_t 
ZSNextEnumeratedObject(struct ZS_thread_state *zs_thread_state,
                        struct ZS_iterator *iterator,
                        char **key,
                        uint32_t *keylen,
                        char **data,
                        uint64_t *datalen)
{
    if (unlikely(!ptr_ZSNextEnumeratedObject))
        undefined("ZSNextEnumeratedObject");

    return (*ptr_ZSNextEnumeratedObject)(zs_thread_state,
                                          iterator,
                                          key,
                                          keylen,
                                          data,
                                          datalen);
}


/*
 * ZSFinishEnumeration
 */
ZS_status_t 
ZSFinishEnumeration(struct ZS_thread_state *zs_thread_state,
                     struct ZS_iterator *iterator)
{
    if (unlikely(!ptr_ZSFinishEnumeration))
        undefined("ZSFinishEnumeration");

    return (*ptr_ZSFinishEnumeration)(zs_thread_state, iterator);
}


/*
 * ZSFlushObject
 */
ZS_status_t 
ZSFlushObject(struct ZS_thread_state *zs_thread_state,
               ZS_cguid_t cguid,
               char *key,
               uint32_t keylen)
{
    if (unlikely(!ptr_ZSFlushObject))
        undefined("ZSFlushObject");

    return (*ptr_ZSFlushObject)(zs_thread_state, cguid, key, keylen);
}


/*
 * ZSFlushContainer
 */
ZS_status_t 
ZSFlushContainer(struct ZS_thread_state *zs_thread_state,
                  ZS_cguid_t cguid)
{
    if (unlikely(!ptr_ZSFlushContainer))
        undefined("ZSFlushContainer");

    return (*ptr_ZSFlushContainer)(zs_thread_state, cguid);
}


/*
 * ZSFlushCache
 */
ZS_status_t 
ZSFlushCache(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSFlushCache))
        undefined("ZSFlushCache");

    return (*ptr_ZSFlushCache)(zs_thread_state);
}


/*
 * ZSGetStats
 */
ZS_status_t 
ZSGetStats(struct ZS_thread_state *zs_thread_state, ZS_stats_t *stats)
{
    if (unlikely(!ptr_ZSGetStats))
        undefined("ZSGetStats");

    return (*ptr_ZSGetStats)(zs_thread_state, stats);
}


/*
 * ZSGetContainerStats
 */
ZS_status_t 
ZSGetContainerStats(struct ZS_thread_state *zs_thread_state,
                     ZS_cguid_t cguid,
                     ZS_stats_t *stats)
{
    if (unlikely(!ptr_ZSGetContainerStats))
        undefined("ZSGetContainerStats");

    return (*ptr_ZSGetContainerStats)(zs_thread_state, cguid, stats);
}


/*
 * ZSStrError
 */
char *
ZSStrError(ZS_status_t zs_errno)
{
    if (unlikely(!ptr_ZSStrError))
        undefined("ZSStrError");

    return (*ptr_ZSStrError)(zs_errno);
}


/*
 * ZSTransactionStart
 */
ZS_status_t 
ZSTransactionStart(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSTransactionStart))
        undefined("ZSTransactionStart");

    return (*ptr_ZSTransactionStart)(zs_thread_state);
}


/*
 * ZSTransactionCommit
 */
ZS_status_t 
ZSTransactionCommit(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSTransactionCommit))
        undefined("ZSTransactionCommit");

    return (*ptr_ZSTransactionCommit)(zs_thread_state);
}

/*
 * ZSTransactionRollback
 */
ZS_status_t 
ZSTransactionRollback(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSTransactionRollback))
        undefined("ZSTransactionRollback");

    return (*ptr_ZSTransactionRollback)(zs_thread_state);
}

/*
 * ZSTransactionQuit
 */
ZS_status_t 
ZSTransactionQuit(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSTransactionQuit))
        undefined("ZSTransactionQuit");

    return (*ptr_ZSTransactionQuit)(zs_thread_state);
}

/*
 * ZSTransactionID
 */
uint64_t
ZSTransactionID(struct ZS_thread_state *zs_thread_state)
{
    if (unlikely(!ptr_ZSTransactionID))
        undefined("ZSTransactionID");

    return (*ptr_ZSTransactionID)(zs_thread_state);
}

/*
 * ZSTransactionService
 */
ZS_status_t
ZSTransactionService(struct ZS_thread_state *zs_thread_state, int cmd, void *arg)
{
    if (unlikely(!ptr_ZSTransactionService))
	undefined("ZSTransactionService");

    return ((*ptr_ZSTransactionService)(zs_thread_state, cmd, arg));
}

/*
 * ZSTransactionGetMode
 */
ZS_status_t
ZSTransactionGetMode(struct ZS_thread_state *zs_thread_state, int *mode)
{
    if (unlikely(!ptr_ZSTransactionGetMode))
	undefined("ZSTransactionGetMode");

    return ((*ptr_ZSTransactionGetMode)(zs_thread_state, mode));
}

/*
 * ZSTransactionSetMode
 */
ZS_status_t
ZSTransactionSetMode(struct ZS_thread_state *zs_thread_state, int mode)
{
    if (unlikely(!ptr_ZSTransactionSetMode))
	undefined("ZSTransactionSetMode");

    return ((*ptr_ZSTransactionSetMode)(zs_thread_state, mode));
}

/*
 * ZSGetVersion
 */
ZS_status_t 
ZSGetVersion(char **str)
{
    parse();
    if (unlikely(!ptr_ZSGetVersion))
        undefined("ZSGetVersion");

    return (*ptr_ZSGetVersion)(str);
}

/*
 * ZSGetRange
 */
ZS_status_t
ZSGetRange(struct ZS_thread_state *zs_thread_state,
            ZS_cguid_t              cguid, 
            ZS_indexid_t            indexid,
            struct ZS_cursor      **cursor,
            ZS_range_meta_t        *rmeta)
{
    if (unlikely(!ptr_ZSGetRange))
        undefined("ZSGetRange");

    return (*ptr_ZSGetRange)(zs_thread_state, cguid, indexid, cursor, rmeta);
}

/*
 * ZSGetNextRange
 */
ZS_status_t
ZSGetNextRange(struct ZS_thread_state *zs_thread_state,  
                struct ZS_cursor       *cursor,
                int                      n_in, 
                int                     *n_out,
                ZS_range_data_t        *values)
{
    if (unlikely(!ptr_ZSGetNextRange))
        undefined("ZSGetNextRange");

    return (*ptr_ZSGetNextRange)(zs_thread_state, cursor, n_in, n_out, values);
}

/*
 * ZSGetRangeFinish
 */
ZS_status_t 
ZSGetRangeFinish(struct ZS_thread_state *zs_thread_state, 
                  struct ZS_cursor *cursor)
{
    if (unlikely(!ptr_ZSGetRangeFinish))
        undefined("ZSGetRangeFinish");

    return (*ptr_ZSGetRangeFinish)(zs_thread_state, cursor);
}

ZS_status_t
ZSCreateContainerSnapshot(struct ZS_thread_state *ts,
							ZS_cguid_t cguid,
							uint64_t *snap_seq)
{
    if (unlikely(!ptr_ZSCreateContainerSnapshot))
        undefined("ZSCreateContainerSnapshot");

    return (*ptr_ZSCreateContainerSnapshot)(ts, cguid, snap_seq);
}

ZS_status_t
ZSDeleteContainerSnapshot(struct ZS_thread_state *ts,
                           ZS_cguid_t cguid,
                           uint64_t snap_seq)
{
    if (unlikely(!ptr_ZSDeleteContainerSnapshot))
        undefined("ZSDeleteContainerSnapshot");

    return (*ptr_ZSDeleteContainerSnapshot)(ts, cguid, snap_seq);
}


ZS_status_t
ZSGetContainerSnapshots(struct ZS_thread_state *ts,
							ZS_cguid_t cguid,
							uint32_t *n_snapshots,
							ZS_container_snapshots_t **snap_seqs)
{
    if (unlikely(!ptr_ZSGetContainerSnapshots))
        undefined("ZSGetContainerSnapshots");

    return (*ptr_ZSGetContainerSnapshots)(ts, cguid, n_snapshots, snap_seqs);
}

/*
 * ZSTLMapDestroy
 */
void 
ZSTLMapDestroy(struct ZSTLMap *pm)
{
    if (unlikely(!ptr_ZSTLMapDestroy))
        undefined("ZSTLMapDestroy");

    return (*ptr_ZSTLMapDestroy)(pm);
}

/*
 * ZSTLMapClear
 */
void 
ZSTLMapClear(struct ZSTLMap *pm)
{
    if (unlikely(!ptr_ZSTLMapClear))
        undefined("ZSTLMapClear");

    return (*ptr_ZSTLMapClear)(pm);
}

/*
 * ZSTLMapCreate
 */
struct ZSTLMapEntry *
ZSTLMapCreate(struct ZSTLMap *pm,
               char *pkey,
               uint32_t keylen,
               char *pdata,
               uint64_t datalen)
{
    if (unlikely(!ptr_ZSTLMapCreate))
        undefined("ZSTLMapCreate");

    return (*ptr_ZSTLMapCreate)(pm, pkey, keylen, pdata, datalen);
}


/*
 * ZSTLMapUpdate
 */
struct ZSTLMapEntry *
ZSTLMapUpdate(struct ZSTLMap *pm,
               char *pkey,
               uint32_t keylen,
               char *pdata,
               uint64_t datalen)
{
    if (unlikely(!ptr_ZSTLMapUpdate))
        undefined("ZSTLMapUpdate");

    return (*ptr_ZSTLMapUpdate)(pm, pkey, keylen, pdata, datalen);
}


/*
 * ZSTLMapSet
 */
struct ZSTLMapEntry *
ZSTLMapSet(struct ZSTLMap *pm,
            char *pkey,
            uint32_t keylen,
            char *pdata,
            uint64_t datalen,
            char **old_pdata,
            uint64_t *old_datalen)
{
    if (unlikely(!ptr_ZSTLMapSet))
        undefined("ZSTLMapSet");

    return (*ptr_ZSTLMapSet)(pm,
                              pkey,
                              keylen,
                              pdata,
                              datalen,
                              old_pdata,
                              old_datalen);
}


/*
 * ZSTLMapGet
 */
struct ZSTLMapEntry *
ZSTLMapGet(struct ZSTLMap *pc,
            char *key,
            uint32_t keylen,
            char **data,
            uint64_t *pdatalen)
{
    if (unlikely(!ptr_ZSTLMapGet))
        undefined("ZSTLMapGet");

    return (*ptr_ZSTLMapGet)(pc, key, keylen, data, pdatalen);
}


/*
 * ZSTLMapIncrRefcnt
 */
int 
ZSTLMapIncrRefcnt(struct ZSTLMap *pm, char *key, uint32_t keylen)
{
    if (unlikely(!ptr_ZSTLMapIncrRefcnt))
        undefined("ZSTLMapIncrRefcnt");

    return (*ptr_ZSTLMapIncrRefcnt)(pm, key, keylen);
}


/*
 * ZSTLMapCheckRefcnts
 */
void 
ZSTLMapCheckRefcnts(struct ZSTLMap *pm)
{
    if (unlikely(!ptr_ZSTLMapCheckRefcnts))
        undefined("ZSTLMapCheckRefcnts");

    return (*ptr_ZSTLMapCheckRefcnts)(pm);
}


/*
 * ZSTLMapRelease
 */
int 
ZSTLMapRelease(struct ZSTLMap *pm, char *key, uint32_t keylen)
{
    if (unlikely(!ptr_ZSTLMapRelease))
        undefined("ZSTLMapRelease");

    return (*ptr_ZSTLMapRelease)(pm, key, keylen);
}


/*
 * ZSTLMapReleaseEntry
 */
int 
ZSTLMapReleaseEntry(struct ZSTLMap *pm, struct ZSTLMapEntry *pme)
{
    if (unlikely(!ptr_ZSTLMapReleaseEntry))
        undefined("ZSTLMapReleaseEntry");

    return (*ptr_ZSTLMapReleaseEntry)(pm, pme);
}


/*
 * ZSTLMapEnum
 */
struct ZSTLIterator *
ZSTLMapEnum(struct ZSTLMap *pm)
{
    if (unlikely(!ptr_ZSTLMapEnum))
        undefined("ZSTLMapEnum");

    return (*ptr_ZSTLMapEnum)(pm);
}


/*
 * ZSTLFinishEnum
 */
void 
ZSTLFinishEnum(struct ZSTLMap *pm, struct ZSTLIterator *iterator)
{
    if (unlikely(!ptr_ZSTLFinishEnum))
        undefined("ZSTLFinishEnum");

    return (*ptr_ZSTLFinishEnum)(pm, iterator);
}


/*
 * ZSTLMapNextEnum
 */
int 
ZSTLMapNextEnum(struct ZSTLMap *pm,
                 struct ZSTLIterator *iterator,
                 char **key,
                 uint32_t *keylen,
                 char **data,
                 uint64_t *datalen)
{
    if (unlikely(!ptr_ZSTLMapNextEnum))
        undefined("ZSTLMapNextEnum");

    return (*ptr_ZSTLMapNextEnum)(pm, iterator, key, keylen, data, datalen);
}


/*
 * ZSTLMapDelete
 */
int 
ZSTLMapDelete(struct ZSTLMap *pm, char *key, uint32_t keylen)
{
    if (unlikely(!ptr_ZSTLMapDelete))
        undefined("ZSTLMapDelete");

    return (*ptr_ZSTLMapDelete)(pm, key, keylen);
}

/*
 * ZSTLMapInit
 */
struct ZSTLMap*
ZSTLMapInit(uint64_t nbuckets, uint64_t max_entries, char use_locks, void (*replacement_callback)(void *callback_data, char *key, uint32_t keylen, char *pdata, uint64_t datalen), void *replacement_callback_data)
{
    if (unlikely(!ptr_ZSTLMapInit))
        undefined("ZSTLMapInit");

    return (*ptr_ZSTLMapInit)(nbuckets, max_entries, use_locks, replacement_callback, replacement_callback_data);
}

/*
 * ZSMPut
 */
ZS_status_t 
ZSMPut(struct ZS_thread_state *zs_ts,
        ZS_cguid_t cguid,
        uint32_t num_objs,
        ZS_obj_t *objs,
	uint32_t flags,
	uint32_t * objs_written)
{
    if (unlikely(!ptr_ZSMPut))
        undefined("ZSMPut");

    return (*ptr_ZSMPut)(zs_ts, cguid, num_objs,
			  objs, flags, objs_written);
}

/*
 * ZSRangeUpdate.
 */
ZS_status_t
ZSRangeUpdate(struct ZS_thread_state *zs_thread_state, 
	       ZS_cguid_t cguid,
	       char *range_key,
	       uint32_t range_key_len,
	       ZS_range_update_cb_t callback_func,
	       void * callback_args,	
	       ZS_range_cmp_cb_t range_cmp_callback,
	       void *range_cmp_callback_args,
	       uint32_t *objs_updated)
{

    if (unlikely(!ptr_ZSRangeUpdate))
        undefined("ZSRangeUpdate");


    return (*ptr_ZSRangeUpdate) (zs_thread_state, cguid, range_key,
				  range_key_len, callback_func, callback_args,
				  range_cmp_callback, range_cmp_callback_args,
				  objs_updated);
}

/*
 * ZSCheckBtree: internal api for testing purpose.
 */
ZS_status_t
ZSCheckBtree(struct ZS_thread_state *zs_thread_state, 
	       ZS_cguid_t cguid)
{

    if (unlikely(!ptr_ZSCheckBtree))
        undefined("ZSCheckBtree");

    return (*ptr_ZSCheckBtree) (zs_thread_state, cguid);
}

/*
 * ZSCheck: internal api for testing purpose.
 */
ZS_status_t
ZSCheck(struct ZS_thread_state *zs_thread_state)
{

    if (unlikely(!ptr_ZSCheck))
        undefined("ZSCheck");

    return (*ptr_ZSCheck) (zs_thread_state);
}

/*
 * ZSIoctl
 */
ZS_status_t
ZSIoctl(struct ZS_thread_state *zs_thread_state, 
         ZS_cguid_t cguid,
         uint32_t ioctl_type,
         void *data)
{

    if (unlikely(!ptr_ZSIoctl))
        undefined("ZSIoctl");


    return (*ptr_ZSIoctl) (zs_thread_state, cguid, ioctl_type, data);
}

ZS_status_t ZSScavenger(struct ZS_state *zs_state) {
	if (unlikely(!ptr_ZSScavenger)) {
		undefined("ZSScavenger");
	}
	return (*ptr_ZSScavenger) (zs_state);
}
ZS_status_t ZSScavengeContainer(struct ZS_state *zs_state, ZS_cguid_t cguid) {
	if (unlikely(!ptr_ZSScavengeContainer)) {
		undefined("ZSScavengeContianer");
	}
	return (*ptr_ZSScavengeContainer) (zs_state, cguid);
}
ZS_status_t ZSScavengeSnapshot(struct ZS_state *zs_state, ZS_cguid_t cguid, uint64_t snap_seq) {
	if (unlikely(!ptr_ZSScavengeSnapshot)) {
                undefined("ZSScavengeSnapshot");
        }
        return (*ptr_ZSScavengeSnapshot) (zs_state, cguid, snap_seq);
}
