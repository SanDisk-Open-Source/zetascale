#!/usr/bin/perl
# Generate fdf_dll.c from fdf.h.
#
# Author: Johann George
# Copyright (c) 2012, SanDisk Corporation.  All rights reserved.

use strict;
use warnings;
use diagnostics;


# Configurable parameters.
#
use constant LineLen => 80;


# Code at beginning.
#
my $Code_start = '
    /*
     * FDF linkage; generated by mkfdfdll.
     * Copyright (c) 2012, SanDisk Corporation.  All rights reserved.
     */
    #include <dlfcn.h>
    #include <stdio.h>
    #include <stdarg.h>
    #include <stdlib.h>
    #include <string.h>
    #include "fdf.h"


    /*
     * Macros.
     */
    #define nel(a)      (sizeof(a)/sizeof(*(a)))
    #define unlikely(x) __builtin_expect((x), 0)


    /*
     * FDF Library locations.
     */
    static char *fdflibs[] ={
        "/usr/lib64/fdf/libfdf.so",
        "/usr/lib/fdf/libfdf.so",
        "/lib64/libfdf.so",
        "/lib/libfdf.so",
        "/usr/local/lib64/libfdf.so",
        "/usr/local/lib/libfdf.so",
        "libfdf.so",
    };


    /*
     * Function pointers.
     */
';


# Code in middle.
#
my $Code_funcs = '
    /*
     * Print out an error message and exit.
     */
    static void
    panic(char *fmt, ...)
    {
        va_list alist;

        va_start(alist, fmt);
        vfprintf(stderr, fmt, alist);
        va_end(alist);
        fprintf(stderr, "\n");
        exit(1);
    }


    /*
     * An undefined symbol was found.
     */
    static void
    undefined(char *sym)
    {
        panic("FDF: undefined symbol: %s", sym);
    }


    /*
     * Determine if the string ends with "No such file or directory".
     */
    static int
    nsfod(char *str)
    {
        char *err = "No such file or directory";
        int  elen = strlen(err);
        int  slen = strlen(str);

        if (slen < elen)
            return 0;
        return !strcmp(str+slen-elen, err);
    }


    /*
     * Load the FDF library.
     */
    static int
    load(char *path)
    {
        int i;
        void  *dl = dlopen(path, RTLD_LAZY);
        char *err = dlerror();

        if (!dl) {
            if (nsfod(err))
                return 0;
            panic("%s", err);
        }
        
        int n = nel(table);
        for (i = 0; i < n; i++) {
            const char *name = table[i].name;
            void *func = dlsym(dl, name);
            if (func)
                *(void **)table[i].func = func;
            else
                fprintf(stderr, "warning: FDF: undefined symbol: %s\n", name);
        }
        return 1;
    }


    /*
     * Load the FDF library.
     */
    static void
    parse(void)
    {
        int i;
        char *lib = getenv("FDF_LIB");

        if (lib) {
            if (load(lib))
                return;
            panic("cannot find FDF_LIB=%s", lib);
        }

        if (load("/usr/lib64/fdf/libfdf.so"))
            return;

        for (i = 0; i < nel(fdflibs); i++)
            if (load(fdflibs[i]))
                return;
        panic("cannot find libfdf.so");
    }
';


# Print out an error message.
#
sub printe (@) {
    my ($str) = @_;
    print STDERR @_, "\n";
}


# Print out an error message and exit.
#
sub panic (@) {
    my ($str) = @_;
    print STDERR @_, "\n";
    exit 1;
}


# Undent a string.
#
sub undent ($) {
    my ($str) = @_;
    $str =~ s/^\n//;
    $str =~ /^( *)/;
    $str =~ s/^$1//gm;
    $str =~ s/\s*$/\n/;
    return $str;
}


# Strip a string on the left side.
#
sub lstrip ($) {
    my ($str) = @_;
    $str =~ s/^\s+//;
    return $str;
}


# Write a string to a file.
#
sub writestr ($$) {
    my ($file, $str) = @_;
    my $fh;
    open($fh, '>', $file) or
        panic "cannot create $file";
    print $fh $str;
}


# Return the contents of an entire file.
#
sub readstr ($) {
    my ($file) = @_;
    my $fh;
    return undef unless open($fh, '<', $file);
    local $/ = undef;
    return <$fh>;
}


# If a symbol contains FDF or SDF, remove it.
#
sub rem_sdf ($) {
    my ($sym) = @_;
    $sym =~ s/^[FS]DF//;
    return $sym;
}


# Scan through an argument list extracting the parameters.
#
sub scan_alist ($) {
    my ($alist) = @_;
    my $patn = '
        \s* (struct \s+ \w+ | \w+)
        \s* (\**)
        \s* (\w+)
        \s*
    ';
    my @args = split /,/, substr($alist, 1, -1);
    my @params;
    for my $arg (@args) {
        $arg =~ /$patn/ox or
            panic "bad parameters: $arg";
        push @params, [$1, $2, $3];
    }
    return \@params;
}


# Return a pattern that matches FDF/SDF function calls in a header file.
#
sub func_patn () {
    if ($] >= 5.012) {
        return '
            ^
            \s* ([FS]DF_\w+|struct \s* FDF_\w+)
            \s* (\**)
            \s* ([FS]DF\w+)
            \s* ( \( (?:[^()]*+ | (?4))* \) )
            \s* ;
        ';
    }

    printe "upgrade to perl 5.12 to handle () inside functions;" .
           " still, doing our best";
    return '
        ^
        \s* ([FS]DF_\w+|struct \s* [FS]DF_\w+)
        \s* (\**)
        \s* ([FS]DF\w+)
        \s* ( \( [^)]* \) )
        \s* ;
    ';
}


# Scan through a prototype list extracting the functions.
#
sub scan_proto ($) {
    my ($data) = @_;
    my $patn = func_patn();
    my %funcs;
    my @funcs;
    while ($data =~ /$patn/gmox) {
        if ($funcs{$3}) {
            printe "function $3 defined more than once";
        } else {
            $funcs{$3} = 1;
            push @funcs, [$1, $2, $3, scan_alist $4];
        }
    }
    return \@funcs;
}


# Make a calling sequence.
#
sub make_call ($$$$) {
    my ($params, $type, $beg, $end) = @_;
    my $i;
    my $s;

    $i = 0;
    $s = $beg;
    for my $p (@$params) {
        my $delim = ++$i < @$params ? ", " : $end;
        $s .= "$p->[0] $p->[1]" if $type;
        $s .= "$p->[2]$delim";
    }
    $s .= "\n";
    return $s if length($s) < LineLen;

    $i = 0;
    $s = $beg;
    my $tab = " " x length($beg);
    for my $p (@$params) {
        $s .= $tab if $i;
        my $delim = ++$i < @$params ? "," : $end;
        $s .= "$p->[0] $p->[1]" if $type;
        $s .= "$p->[2]$delim\n";
    }
    return $s;
}


# Make link functions.
#
sub make_link_funcs ($) {
    my ($funcs) = @_;
    my $str = "";
    for my $func (@$funcs) {
        my $name   = $func->[2];
        my $params = $func->[3];
        $str .= "\n\n";
        $str .= "/*\n";
        $str .= " * $name\n";
        $str .= " */\n";
        $str .= "$func->[0] $func->[1]\n";
        $str .= make_call $params, 1, "$name(", ")";

        my $half = rem_sdf $name;
        $str .= "{\n";
        $str .= "    parse();\n" if ($half eq 'Init');
        $str .= "    if (unlikely(!ptr_$name))\n";
        $str .= "        undefined(\"$name\");\n";
        $str .= "\n";
        $str .= make_call $params, 0, "    return (*ptr_$name)(", ");";
        $str .= "}\n";
    }
    return $str;
}


# Find the maximum value of a vector containing non-negative values.
#
sub maxv (@) {
    my $max = 0;
    foreach (@_) {
        $max = $_ if $_ > $max;
    }
    return $max;
}


use Qlib;
# Make link table.
#
sub make_link_table ($) {
    my ($funcs) = @_;
    my $str = undent '
        /*
         * Linkage table.
         */
        static struct {
            const char *name;
            void       *func;
        } table[] ={
    ';

    my $max = maxv map {length($_->[2])} @$funcs;
    for my $func (@$funcs) {
        my $full = $func->[2];
        my $fill = " " x ($max - length($full));
        $str .= "    { \"$full\",$fill  &ptr_$full$fill },\n";
    }
    $str .= "};\n";
    return $str;
}


# Make link prototypes.
#
sub make_link_proto ($) {
    my ($funcs) = @_;
    my $str = "";
    for my $func (@$funcs) {
        my $name = $func->[2];
        my $params = $func->[3];
        $str .= "\n";
        $str .= "static $func->[0] $func->[1]\n";
        $str .= make_call $params, 1, "(*ptr_$name)(", ");";
    }
    return $str;
}


# Make the linking interface.
#
sub make_link ($) {
    my ($funcs) = @_;
    my $str = "";
    $str .= undent $Code_start;
    $str .= lstrip make_link_proto $funcs;
    $str .= "\n\n";
    $str .= make_link_table $funcs;
    $str .= "\n\n";
    $str .= undent $Code_funcs;
    $str .= make_link_funcs $funcs;
    $str =~ s/^\n*//;
    print $str;
}


sub main () {
    my $path = $ARGV[0];
    panic "usage: mkfdfdll fdf.h >fdf_dll.c" unless $path;
    my $data = readstr $path;
    defined $data or
        panic "failed to open file: $path";
    my $funcs = scan_proto $data;
    make_link $funcs;
}


main;
