/*
 * Copyright (c) 2013 SanDisk Corporation.  All rights reserved.
 *
 * File:   interface.c
 * Author: Niranjan Neelakanta
 *
 * Created on March 25, 2013.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "interface.h"
#include "versions.h"

const char license_header[]= "@@LICENSE@@\n";
const char format_header[]= "@@FORMAT@@\n";
const char end_header[]= "@@END@@\n";

//Messages are indexed by enum lic_state.
char *lic_state_msg[] = {
	"",
	"License is valid",
	"License has expired",
	"License period has not started",
	"Internal error",
	"I/O error",
	"License file format not supported",
	"License file is not in valid format",
	"Data is not entered for one of the fields",
	"License key does not match",
	"License is not for this product",
	"License is not for this version",
	"License is not for this machine",
	"License file is invalid",
};

char *lic_period_type[] = {
	"Invalid",
	"Evaluation",
	"Development",
	"Periodic",
	"Permanent",
};

char *lic_installation_type[] = {
	"Invalid",
	"Stand alone",
	"Multiple",
};


static int get_version_specific_contents(char *, char **, int *, int *);


/*
 * NAME:	generate_license_file
 *
 * DESCRIPTION:
 * 	This routine generates blank license file for the 
 *	version specified. If 'ver' argument is not provided,
 *	it generates file of latest version.
 *
 */

int
generate_license_file(char *ver, char *path)
{
	int		major, minor, indx;
	FILE		*fd;
	const char 	license_blank_header[] = "NOTE: Machine-generated content. \n© Copyright SanDisk Inc. 2013. All rights reserved.\nhttp://www.sandisk.com\n\nThis is template file for generating license. Input the details in CONTACT and PARTICULARS section. Use fdflicense command to generate license.\n";
	char		version[32] = {0};

	if (path) {
		if ((fd = fopen(path, "w+")) == NULL) {
			perror("Opening file failed");
			return -1;
		}
	} else {
		return -1;
	}

	/*
	 * If version is not provided. Get latest version supported, and
	 * call interface to generate license file.
	 */
	if (ver == NULL) {
		get_latest_file_format(&major, &minor, &indx);
		sprintf(version, "%d.%d", major, minor);
	} else {
		strcpy(version, ver);
		if (sscanf(ver, "%d.%d", &major, &minor) < 2) {
			fprintf(stderr, "Version parameter is not valid\n");
			return -1;
		}
		get_fileops_indx(major, minor, &indx);
		if (indx == -1) {
			fprintf(stderr, "Unsupported license file format\n");
			return -1;
		}

	}
	fprintf(stderr, "Using version %s\n", version);

	if (fwrite(license_header, strlen(license_header), 1, fd) < 1) {
		goto out;
	}
	if (fwrite(license_blank_header, strlen(license_blank_header), 1, fd) < 1) {
		goto out;
	}
	if (fwrite(format_header, strlen(format_header), 1, fd) < 1) {
		goto out;
	}
	if (fwrite("v", sizeof(char), 1, fd) < 1) {
		goto out;
	}
	if (fwrite(version, strlen(version), 1, fd) < 1) {
		goto out;
	}
	if (fwrite("\n", sizeof(char), 1, fd) < 1) {
		goto out;
	}		

	/*
	 * Write version specific information using the interface
	 * exported.
	 */
	if (lic_list[0].flf_gen_lic_file(fd) == -1) {
		fprintf(stderr, "Could not write contents to file\n");
		return -1;
	}

	if (fwrite(end_header, strlen(end_header), 1, fd) < 1) {
		goto out;
	}
	return 0;
out:
	perror("Write failed");
	fclose(fd);
	return -1;
}

/*
 * NAME:	generate_license_for_file
 *
 * DESCRIPTION:
 * 	This routine generates blank license file for the 
 *	version specified. If 'ver' argument is not provided,
 *	it generates file of latest version.
 *
 */
int
generate_license_for_file(char *input_file, char *output_file)
{
	int		major, minor, license_size, indx = -1;
	FILE		*in_fd, *out_fd;
	char 		*license, version[32] = {0};
	const char 	license_gen_header[] = "NOTE: Machine-generated content. \n© Copyright SanDisk Inc. 2013. All rights reserved.\nhttp://www.sandisk.com\n\nDO NOT EDIT THIS FILE.\n";
	char		*input = NULL, *output = NULL;
	struct stat	statbuf;
	enum lic_state	ret;
	int		retval;


	if (stat(input_file, &statbuf) != 0) {
		fprintf(stderr, "Could not open license file at '%s'.\n", input_file);
		return -1;
	}
	license_size = statbuf.st_size;
	if ((license = malloc(license_size + 1)) == NULL) {
		fprintf(stderr, "Out of memory!\n");
		return -1;
	}

	if (NULL == (in_fd = fopen(input_file, "r"))) {
		fprintf(stderr, "Error opening file: %s\n", input_file);
		return -1;
	}
	if (fread((void *) license, sizeof(char), license_size, in_fd) != 
								license_size) {
		fprintf(stderr, "Problem reading license file at '%s'.\n",
								input_file);
		return -1;
	}
	retval = get_version_specific_contents(license, &input, &major, &minor);

	if (retval == -2) {
		goto fmt_out;
	} else if (retval == -1) {
		fprintf(stderr, "Out of memory\n");
		return -1;
	}
	sprintf(version, "v%d.%d", major, minor);
	if (NULL == (out_fd = fopen(output_file, "w+"))) {
		fprintf(stderr, "Error opening file: %s\n", output_file);
		goto out;
	}
	get_fileops_indx(major, minor, &indx);
	if (indx == -1) { 
		fprintf(stderr, "Unsupported license file format\n");
		goto out;
	}
	if ((ret = lic_list[indx].flf_gen_lic(input, &output)) != LS_VALID) {
		fprintf(stderr, "Error writing to file %s, %s\n", output_file, lic_state_msg[ret]);
		goto out;
	}

	if (fwrite(license_header, strlen(license_header), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite(license_gen_header, strlen(license_gen_header), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite(format_header, strlen(format_header), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite(version, strlen(version), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite("\n", sizeof(char), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite(output, strlen(output), 1, out_fd) < 1) {
		goto wrt_out;
	}
	if (fwrite(end_header, strlen(end_header), 1, out_fd) < 1) {
		goto wrt_out;
	}
	fclose(in_fd);
	fclose(out_fd);
        return 0;
fmt_out:
	fclose(in_fd);
	fprintf(stderr, "License file format is not as expected\n");
	return -1;
wrt_out:
	perror("Error writing to license file\n");
out:
	if (in_fd) fclose(in_fd);
	if (out_fd) fclose(out_fd);
	if (input) free(input);
	return -1;

}

/*
 * NAME:	generate_license_for_file
 *
 * DESCRIPTION:
 * 	This routine checks the license file whether it is valid
 *	or not.
 *
 */
int
check_license_file(char *input_file)
{
	FILE		*in_fd;
	struct stat	statbuf;
	char		*input;
	int		major, minor, license_size, indx;
	char 		*license;
	enum lic_state	ret;
	int		retval;

	if (stat(input_file, &statbuf) != 0) {
		fprintf(stderr, "Could not open license file at '%s'.\n", input_file);
		return -1;
	}
	license_size = statbuf.st_size;
	if ((license = malloc(license_size + 1)) == NULL) {
		fprintf(stderr, "Out of memory!\n");
		return -1;
	}

	if (NULL == (in_fd = fopen(input_file, "r"))) {
		fprintf(stderr, "Error opening file: %s\n", input_file);
		return -1;
	}
	if (fread((void *) license, license_size, 1, in_fd) < 1) {
		fprintf(stderr, "Problem reading license file at '%s'.\n",
								input_file);
		return -1;
	}

	retval = get_version_specific_contents(license, &input, &major, &minor);

	if (retval == -2) {
		goto fmt_out;
	} else if (retval == -1) {
		fprintf(stderr, "Out of memory\n");
		return -1;
	}

	get_fileops_indx(major, minor, &indx);
	if (indx == -1) { 
		fprintf(stderr, "Unsupported license file format\n");
		goto out;
	}
	if ((ret = lic_list[indx].flf_val_lic_file(input)) == LS_VALID) {
		fprintf(stderr, "License file %s is valid\n", input_file);
	} else {
		fprintf(stderr, "Validation of license file %s failed, %s\n",
				input_file, lic_state_msg[ret]);
		goto out;
	}
	fclose(in_fd);
        return 0;
fmt_out:
	if (in_fd) fclose(in_fd);
	fprintf(stderr, "%s\n", lic_state_msg[LS_UNSUPPORTED_FMT]);
	return -1;
out:
	if (input) free(input);
	return -1;
}

/*
 * NAME:	get_license_details
 *
 * DESCRIPTION:
 * 	This routine returns the details in the license file only if
 *	it is valid.
 *
 */
void
get_license_details(char *input_file, lic_data_t *data)
{
	FILE		*in_fd;
	struct stat	statbuf;
	char		*input = NULL;
	int		major, minor, license_size, indx;
	char 		*license = NULL;
	int		retval;

	if (stat(input_file, &statbuf) != 0) {
		data->fld_state = LS_INVALID;
		return;
	}
	license_size = statbuf.st_size;
	if ((license = malloc(license_size + 1)) == NULL) {
		data->fld_state = LS_INTERNAL_ERR;
		return;
	}

	if (NULL == (in_fd = fopen(input_file, "r"))) {
		data->fld_state = LS_INVALID;
		return;
	}
	if (fread((void *) license, license_size, 1, in_fd) < 1) {
		data->fld_state = LS_INVALID;
		goto out;
	}
	retval = get_version_specific_contents(license, &input, &major, &minor);

	if (retval == -2) {
		goto fmt_out;
	} else if (retval == -1) {
		data->fld_state = LS_INTERNAL_ERR;
		goto out;
	}

	get_fileops_indx(major, minor, &indx);
	if (indx == -1) { 
		data->fld_state = LS_UNSUPPORTED_FMT;
		goto out;
	}
	data->fld_major = major;
	data->fld_minor = minor;
	lic_list[indx].flf_get_license_details(input, data);
        goto out;
fmt_out:
	data->fld_state = LS_FORMAT_INVALID;
out:
	if (in_fd) fclose(in_fd);
	if (input) free(input);
	if (license) free(license);
	return;
}

/*
 * This routine returns file format version major and minor number.
 * And the text which is version specific.
 */
static int
get_version_specific_contents(char *license, char **input, int *major, int *minor)
{
	char 		version[32] = {0};
	char 		*lic_hdr, *fmt_hdr, *rem, *end_hdr;

	if (NULL == (lic_hdr = strstr(license, license_header))) {
		return -1;
	}

	if (NULL != (fmt_hdr = strstr(license, format_header))) {
		if (NULL != (fmt_hdr = strstr(fmt_hdr, "\n"))) {
			fmt_hdr += 1;
			if (NULL != (rem = strstr(fmt_hdr, "\n"))) {
				strncpy(version, fmt_hdr, rem - fmt_hdr);
				if (sscanf(version, "v%d.%d", major, minor)
								< 2) {
					goto fmt_inval;
				}
				rem = rem + 1;
				end_hdr = strstr(license, end_header);
				if (end_hdr != NULL) {
					*input = (char *)malloc(sizeof(char) 
							* (int)(end_hdr - rem + 1));
					if (!*input) {
						return -1;
					}
					strncpy(*input, rem, (int)(end_hdr - rem));
					*((*input) + (end_hdr - rem)) = '\0';
				} else {
					goto fmt_inval;
				}
			} else {
				goto fmt_inval;
			}
		} else {
			goto fmt_inval;
		}
	} else {
		goto fmt_inval;
	}
	return 0;
fmt_inval:
	return -2;
}
